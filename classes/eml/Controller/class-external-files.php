<?php
/**
 * This file contains a controller-object to handle external files operations.
 *
 * @package thread\eml
 */

namespace threadi\eml\Controller;

// prevent direct access.
defined( 'ABSPATH' ) || exit;

use threadi\eml\Helper;
use threadi\eml\Model\external_file;
use threadi\eml\Model\log;
use WP_Query;

/**
 * Controller for external file-urls-tasks.
 *
 * @noinspection PhpUnused
 */
class External_Files {
	/**
	 * Instance of actual object.
	 *
	 * @var External_Files|null
	 */
	private static ?External_Files $instance = null;

	/**
	 * Log-object.
	 *
	 * @var log
	 */
	private log $log;

	/**
	 * The login.
	 *
	 * @var string
	 */
	private string $login = '';

	/**
	 * The password.
	 *
	 * @var string
	 */
	private string $password = '';

	/**
	 * Constructor, not used as this a Singleton object.
	 */
	private function __construct() {
		// get log-object.
		$this->log = Log::get_instance();
	}

	/**
	 * Prevent cloning of this object.
	 *
	 * @return void
	 */
	private function __clone() { }

	/**
	 * Return instance of this object as singleton.
	 *
	 * @return External_Files
	 */
	public static function get_instance(): External_Files {
		if ( is_null( self::$instance ) ) {
			self::$instance = new External_Files();
		}

		return self::$instance;
	}

	/**
	 * Get all external files in media library as external_file-object-array.
	 *
	 * @return array
	 */
	public function get_files_in_media_library(): array {
		$query  = array(
			'post_type'      => 'attachment',
			'post_status'    => 'inherit',
			'meta_query'     => array(
				array(
					'key'     => EML_POST_META_URL,
					'compare' => 'EXISTS',
				),
			),
			'posts_per_page' => -1,
			'fields'         => 'ids',
		);
		$result = new WP_Query( $query );
		if ( $result->post_count > 0 ) {
			$results = array();
			foreach ( $result->posts as $attachment_id ) {
				$external_file_obj = $this->get_file( $attachment_id );
				if ( $external_file_obj ) {
					$results[] = $external_file_obj;
				}
			}
			return $results;
		}
		return array();
	}

	/**
	 * Add the given file-url in media library as external-file-object.
	 *
	 * @param string $url   The URL to add.
	 *
	 * @return bool true if URL is added successfully.
	 */
	public function add_file( string $url ): bool {
		$false = false;
		/**
		 * Filter the given URL against custom blacklists.
		 *
		 * @since 2.0.0 Available since 2.0.0.
		 * @param bool $false Return true if blacklist matches.
		 * @noinspection PhpConditionAlreadyCheckedInspection
		 */
		if ( apply_filters( 'eml_blacklist', $false, $url ) ) {
			return false;
		}

		/**
		 * Get the handler for this url depending on its protocol.
		 */
		$protocol_handler_obj = Protocols::get_instance()->get_protocol_object_for_url( $url );

		/**
		 * Do nothing if url is using a not supported tcp protocol.
		 */
		if ( ! $protocol_handler_obj ) {
			return false;
		}

		/**
		 * Add the given credentials, even if none are set.
		 */
		$protocol_handler_obj->set_login( $this->get_login() );
		$protocol_handler_obj->set_password( $this->get_password() );

		/**
		 * Do nothing if file-check is not successful.
		 */
		if ( false === $protocol_handler_obj->check_url() ) {
			return false;
		}

		/**
		 * Do nothing if availability-check is not successful.
		 */
		if ( false === $protocol_handler_obj->check_availability() ) {
			return false;
		}

		/**
		 * Get user the attachment would be assigned to.
		 */
		$user_id = Helper::get_current_user_id();

		/**
		 * Filter the user_id for a single file during import.
		 *
		 * @since 1.1.0 Available since 1.1.0
		 *
		 * @param int $user_id The title generated by importer.
		 * @param string $url The requested external URL.
		 */
		$user_id = apply_filters( 'eml_file_import_user', $user_id, $url );

		/**
		 * Get file information via http-header.
		 */
		$file_data = $protocol_handler_obj->get_external_file_infos();

		/**
		 * Bail on error for tmp-file.
		 */
		if ( ! empty( $file_data['tmp-file'] ) && is_wp_error( $file_data['tmp-file'] ) ) {
			/* translators: %1$s will be replaced by the file-URL */
			Log::get_instance()->create( sprintf( __( 'Given string %1$s results in error during request: <pre>%2$s</pre>', 'external-files-in-media-library' ), esc_url( $url ), wp_json_encode( $file_data['tmp-file'] ) ), esc_url( $url ), 'error', 0 );
			return false;
		}

		/**
		 * Filter the title for a single file during import.
		 *
		 * @since 1.1.0 Available since 1.1.0
		 *
		 * @param string $title The title generated by importer.
		 * @param string $url The requested external URL.
		 * @param array $file_data List of file settings detected by importer.
		 */
		$title = apply_filters( 'eml_file_import_title', $file_data['title'], $url, $file_data );

		/**
		 * Prepare attachment-post-settings.
		 */
		$post_array = array(
			'post_author' => $user_id,
		);

		/**
		 * Save this file local if protocol requires it.
		 */
		if ( $protocol_handler_obj->should_be_saved_local() ) {
			// import file as image via WP-own functions.
			$array = array(
				'name'     => $title,
				'type'     => $file_data['mime-type'],
				'tmp_name' => $file_data['tmp-file'],
				'error'    => 0,
				'size'     => $file_data['filesize'],
			);

			$attachment_id = media_handle_sideload( $array, 0, null, $post_array );
			if ( ! is_wp_error( $attachment_id ) ) {
				$file_data['local'] = true;
			} else {
				// log the event.
				/* translators: %1$s will be replaced by the file-URL */
				Log::get_instance()->create( sprintf( __( 'URL %1$s could not be downloaded.', 'external-files-in-media-library' ), $url ), $url, 'error', 0 );
			}
		} else {
			/**
			 * For all other files: simply create the attachment.
			 */
			$attachment_id = wp_insert_attachment( $post_array, $url );
		}

		// bail on any error.
		if ( is_wp_error( $attachment_id ) ) {
			/* translators: %1$s will be replaced by the file-URL, %2$s will be replaced by a WP-error-message */
			$this->log->create( sprintf( __( 'URL %1$s could not be saved because of this error: %2$s', 'external-files-in-media-library' ), $url, $attachment_id->errors['upload_error'][0] ), $url, 'error', 0 );
			return false;
		}

		// get external file object. to update its settings.
		$external_file_obj = $this->get_file( $attachment_id );

		// bail if object could not be loaded.
		if( ! $external_file_obj ) {
			/* translators: %1$s will be replaced by the file-URL */
			$this->log->create( sprintf( __( 'External file object for URL %1$s could not be loaded.', 'external-files-in-media-library' ), $url ), $url, 'error', 0 );
			return false;
		}

		// mark this attachment as one of our own plugin through setting the URL.
		$external_file_obj->set_url( $url );

		// set title.
		$external_file_obj->set_title( $title );

		// set mime-type.
		$external_file_obj->set_mime_type( $file_data['mime-type'] );

		// set availability-status (true for 'is available', false if not).
		$external_file_obj->set_availability( true );

		// set filesize.
		$external_file_obj->set_filesize( $file_data['filesize'] );

		// mark if this file is an external file locally saved.
		$external_file_obj->set_is_local_saved( $file_data['local'] );

		// set meta-data for images if mode is enabled for this.
		if ( ! $protocol_handler_obj->should_be_saved_local() && ! empty( $file_data['tmp-file'] ) ) {
			$image_meta = wp_create_image_subsizes( $file_data['tmp-file'], $attachment_id );

			// set file to our url.
			$image_meta['file'] = $url;

			// save the resulting image-data.
			wp_update_attachment_metadata( $attachment_id, $image_meta );
		}

		// return true as the file has been created successfully.
		/* translators: %1$s will be replaced by the file-URL */
		$this->log->create( sprintf( __( 'URL %1$s successfully added in media library.', 'external-files-in-media-library' ), $url ), $url, 'success', 0 );

		// save the credentials on the object, if set.
		$external_file_obj->set_login( $this->get_login() );
		$external_file_obj->set_password( $this->get_password() );

		// return ok.
		return true;
	}

	/**
	 * Log deletion of external urls in media library.
	 *
	 * @param int $attachment_id  The attachment_id which will be deleted.
	 *
	 * @return void
	 */
	public function log_url_deletion( int $attachment_id ): void {
		// get the external file object.
		$external_file = $this->get_file( $attachment_id );

		// bail if it is not an external file.
		if ( ! $external_file || false === $external_file->is_valid() ) {
			return;
		}

		// log deletion.
		/* translators: %1$s will be replaced by the file-URL */
		Log::get_instance()->create( sprintf( __( 'URL %1$s has been deleted from media library.', 'external-files-in-media-library' ), esc_url( $external_file->get_url() ) ), $external_file->get_url(), 'success', 1 );
	}

	/**
	 * Return external_file object of single attachment by given ID without checking its availability.
	 *
	 * @param int $attachment_id    The attachment_id where we want to call the External_File-object.
	 * @return false|External_File
	 */
	public function get_file( int $attachment_id ): false|External_File {
		if ( false !== is_attachment( $attachment_id ) ) {
			return false;
		}
		return new External_File( $attachment_id );
	}

	/**
	 * Delete the given external-file-object with all its data from media library.
	 *
	 * @param External_File $external_file_obj  The External_File which will be deleted.
	 *
	 * @return void
	 */
	public function delete_file( External_File $external_file_obj ): void {
		wp_delete_attachment( $external_file_obj->get_id(), true );
	}

	/**
	 * Check all external files regarding their availability.
	 *
	 * @return void
	 */
	public function check_files(): void {
		$files = $this->get_files_in_media_library();
		foreach ( $files as $external_file_obj ) {
			// bail if obj is not an external file object.
			if ( ! $external_file_obj instanceof External_File ) {
				continue;
			}

			// get the protocol handler for this URL.
			$protocol_handler = Protocols::get_instance()->get_protocol_object_for_external_file( $external_file_obj );

			// get and save its availability.
			$external_file_obj->set_availability( $protocol_handler->check_availability() );
		}
	}

	/**
	 * Get all imported external files.
	 *
	 * @return array
	 */
	public function get_imported_external_files(): array {
		$query  = array(
			'post_type'      => 'attachment',
			'post_status'    => 'inherit',
			'meta_query'     => array(
				'relation' => 'AND',
				array(
					'key'     => EML_POST_META_URL,
					'compare' => 'EXISTS',
				),
				array(
					'key'   => EML_POST_IMPORT_MARKER,
					'value' => 1,
				),
			),
			'posts_per_page' => -1,
			'fields'         => 'ids',
		);
		$result = new WP_Query( $query );
		if ( $result->post_count > 0 ) {
			$results = array();
			foreach ( $result->posts as $attachment_id ) {
				$external_file_obj = $this->get_file( $attachment_id );
				if ( $external_file_obj ) {
					$results[] = $external_file_obj;
				}
			}
			return $results;
		}
		return array();
	}

	/**
	 * Get file-object by URL.
	 *
	 * @param string $url The file-url we search.
	 *
	 * @return bool|External_File
	 */
	public function get_file_by_url( string $url ): ?External_File {
		if ( ! empty( $url ) ) {
			$query  = array(
				'post_type'      => 'attachment',
				'post_status'    => 'inherit',
				'meta_query'     => array(
					array(
						'key'     => EML_POST_META_URL,
						'value'   => $url,
						'compare' => '=',
					),
				),
				'posts_per_page' => 1,
				'fields'         => 'ids',
			);
			$result = new WP_Query( $query );
			if ( 1 === $result->post_count ) {
				$external_file_obj = $this->get_file( $result->posts[0] );
				if ( $external_file_obj && $external_file_obj->is_valid() ) {
					return $external_file_obj;
				}
			}
		}
		return false;
	}

	/**
	 * Get file-object by its title.
	 *
	 * @param string $title The file-url we search.
	 *
	 * @return bool|External_File
	 */
	public function get_file_by_title( string $title ): bool|External_File {
		if ( ! empty( $title ) ) {
			$query  = array(
				'title'          => $title,
				'post_type'      => 'attachment',
				'post_status'    => 'inherit',
				'meta_query'     => array(
					array(
						'key'     => EML_POST_META_URL,
						'compare' => 'EXISTS',
					),
				),
				'posts_per_page' => -1,
				'fields'         => 'ids',
			);
			$result = new WP_Query( $query );
			if ( 1 === $result->post_count ) {
				$external_file_obj = $this->get_file( $result->posts[0] );
				if ( $external_file_obj && $external_file_obj->is_valid() ) {
					return $external_file_obj;
				}
			}
		}
		return false;
	}

	/**
	 * Return the cache-directory for proxied external files.
	 * Handles also the existence of the directory.
	 *
	 * @return string
	 */
	public function get_cache_directory(): string {
		// create string with path for directory.
		$path = trailingslashit( WP_CONTENT_DIR ) . 'cache/eml/';

		// create it if necessary.
		$this->create_cache_directory( $path );

		// return path.
		return $path;
	}

	/**
	 * Create cache directory.
	 *
	 * @param string $path The path to the cache directory.
	 * @return void
	 */
	private function create_cache_directory( string $path ): void {
		if ( ! file_exists( $path ) ) {
			if ( false === wp_mkdir_p( $path ) ) {
				$this->log->create( __( 'Error creating cache directory.', 'external-files-in-media-library' ), '', 'error', 0 );
			}
		}
	}

	/**
	 * Delete the cache directory.
	 *
	 * @return void
	 */
	public function delete_cache_directory(): void {
		Helper::delete_directory_recursively( $this->get_cache_directory() );
	}

	/**
	 * If file is deleted, delete also its proxy-cache, if set.
	 *
	 * @param int $attachment_id The ID of the attachment.
	 * @return void
	 */
	public function delete_file_from_cache( int $attachment_id ): void {
		// get the external file object.
		$external_file = $this->get_file( $attachment_id );

		// bail if it is not an external file.
		if ( ! $external_file || false === $external_file->is_valid() ) {
			return;
		}

		// call cache file deletion.
		$external_file->delete_cache();
	}

	/**
	 * Return the login.
	 *
	 * @return string
	 */
	private function get_login(): string {
		return $this->login;
	}

	/**
	 * Set the login.
	 *
	 * @param string $login The login.
	 *
	 * @return void
	 */
	public function set_login( string $login ): void {
		$this->login = $login;
	}

	/**
	 * Return the password.
	 *
	 * @return string
	 */
	private function get_password(): string {
		return $this->password;
	}

	/**
	 * Set the password.
	 *
	 * @param string $password The password.
	 *
	 * @return void
	 */
	public function set_password( string $password ): void {
		$this->password = $password;
	}
}
